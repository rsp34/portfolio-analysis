# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_portfolio.ipynb.

# %% auto 0
__all__ = ['to_datetime', 'create_monthly_rebalance_dates', 'create_monthly_deposits', 'Holding', 'FixedAllocationPortfolio',
           'Returns']

# %% ../nbs/00_portfolio.ipynb 3
from fastcore.utils import *

# %% ../nbs/00_portfolio.ipynb 4
import pendulum

# %% ../nbs/00_portfolio.ipynb 7
import yfinance as yf

# %% ../nbs/00_portfolio.ipynb 13
import pandas as pd
from datetime import datetime

# %% ../nbs/00_portfolio.ipynb 14
to_datetime = lambda date_string: datetime.strptime(date_string,"%d/%m/%Y")
def create_monthly_deposits(start:str,        # Date of the first montly deposit.
                            end:str,          # Date of the last monthly deposit
                            deposit:float):    # Value of monthly deposit
    dti = pd.bdate_range(start=to_datetime(start),end=to_datetime(end),freq='BM')
    deposits = [deposit]*len(dti)
    return pd.Series([deposit]*len(dti), index=dti, name='deposits')

# %% ../nbs/00_portfolio.ipynb 18
import matplotlib.pyplot as plt
import warnings

# %% ../nbs/00_portfolio.ipynb 19
class Holding:
    "A holding for fund with data available on yfinance"
    def __init__(self,
                 fund:str,                      # Name of the fund
                 ticker:str,                    # Ticker symbol for the stock
                 product_cost:float,            # Sum of all fees expressed as a percentage
                 deposits):                     # Timeseries dataframe of deposits
                 
        
        self.fund = fund
        self.history = yf.Ticker(ticker).history(period='max', # valid periods: 1d,5d,1mo,3mo,6mo,1y,2y,5y,10y,ytd,max
                                                 interval='1d', # valid intervals: 1m,2m,5m,15m,30m,60m,90m,1h,1d,5d,1wk,1mo,3mo
                                                 actions=False)
        self.product_cost = product_cost
        
        # Where we've specified a timeseries where values predate the oldest time in our ticker,
        # we give a warning and then assume that the accumulated lump sum was invested at the earliest
        # possible date.
        if self.history.index[0] > deposits.index[0]:
            initial_deposit = deposits[deposits.index <= self.history.index[0]].sum()
            deposits = deposits[deposits.index <= self.history.index[0]]
            deposits.iat[0,0] = initial_deposit
            warnings.warn(f"""Deposits predate initial date of {self.history.index[0]} where prices are available for {fund}.
                              Accumulated deposit of {initial_deposit} deposited on this date.""")
        else:
             self.history = self.history.iloc[self.history.index >= deposits.index[0]]
            
        self.history['deposits']  = deposits
        self.history['deposits']  = self.history['deposits'].fillna(0)
        
        self = self.compute_value()
        
        # A holding can never have cumulative deposits less than zero.
        
    def compute_value(self):
        
        self.history['cum_deposits'] = self.history['deposits'].cumsum()
        self.history['units']        = self.history['deposits']/self.history['Close']
        self.history['cum_units']    = self.history['units'].cumsum()
        self.history['cum_value']    = self.history['cum_units']*self.history['Close']
        self.history['fees'] = ((1+self.product_cost/100)**(1/365)-1)*self.history['cum_value']
        
        return self

# %% ../nbs/00_portfolio.ipynb 36
class FixedAllocationPortfolio:
    "A collection of holdings of funds with data available on yfinance with a fixed allocation of each deposit made."
    def __init__(self,
                 fund:list,          # List of fund names
                 ticker:list,        # List of fund tickers
                 product_cost:list,  # List of fees for each fund expressed as a percentage and comprising all fees for a given fund
                 allocation:list,    # Allocation of each deposit as a fraction. Must sum to one.
                 deposits):          # Timeseries dataframe of deposits
        
        # Check fund, ticker, product_cost and allocation are all lists of equal length
        assert(all([len(input)==len(fund) for input in [ticker, product_cost, allocation]]))
        
        # Check that allocation sums to 1
        assert(sum(allocation)==1)
        
        # Record the inputs
        self.deposits = deposits
        self.allocation = allocation
        self.fund = fund
        
        # Create a holding for each fund
        self.holdings = [Holding(fund[i],ticker[i],product_cost[i],deposits*allocation[i]) for i in range(len(fund))]
        
        
    def rebalance(self,rebalance_dates):
        
        # We rebalance on the dates specified. If a rebalancing date is prior a funds 
        # inception date then the fund is ignore in the rebalancing.
        
        # It is assumed that fees are paid for with an external account and that the fees
        # are accrued daily.
        
        holdings = self.holdings
        
        matching_rows = holdings[0].history.index.get_indexer(rebalance_dates,method='nearest')
        
        for row in matching_rows:
            
            # Compute the current allocation
            current_allocation = list()
            for i in range(len(holdings)):
                cum_value = holdings[i].history.iloc[row].loc['cum_value'];
                if cum_value == "nan":
                    # If the deposits pre-date the fund, we use the deposit value in 
                    # the allocation computation.
                    cum_value = holdings[i].history.iloc[row].loc['cum_deposits'];
                current_allocation.append(cum_value)
                
            # Compute target allocations based on asset weightings
            total_value = sum(current_allocation)
            target_allocation = [fraction*total_value for fraction in self.allocation]
            
            # Update units, cum_units and cum_value in light of the new breakdown
            # These are really properties of the holding...
            cum_value_idx = holdings[i].history.columns.get_loc("cum_value")
            deposit_idx = holdings[i].history.columns.get_loc("deposits")
            
            for i in range(len(holdings)):
                # Some special, consideration needs to 
                holdings[i].history.iloc[row,deposit_idx] = holdings[i].history.iloc[row,deposit_idx] \
                                                                   + (target_allocation[i] - holdings[i].history.iloc[row,cum_value_idx])
                holdings[i].compute_value()
            
            self.holdings = holdings
            return self

# %% ../nbs/00_portfolio.ipynb 42
class Returns:
    def __init__(self,
                 name:    str ,   # Description of the returns - typically used as title
                 holdings: list):  # List of holdings
    
            self.name = name
            self.history = holdings[0].history[["deposits","cum_value","fees"]]
            for i in range(1,len(holdings)):
                self.history += holdings[i].history[["deposits","cum_value","fees"]]

# %% ../nbs/00_portfolio.ipynb 44
@patch
def to_returns(self:Holding):
    return Returns(self.fund,[self])

# %% ../nbs/00_portfolio.ipynb 49
@patch
def to_returns(self:FixedAllocationPortfolio):
    
    name = f"{100*self.allocation[0]}% {self.fund[0]}"
    for i in range(1,len(self.holdings)):
        name += f", {100*self.allocation[i]}% {self.fund[i]}"

    return Returns(name,self.holdings)

# %% ../nbs/00_portfolio.ipynb 54
@patch
def profit(self:Returns):
    
    if self.history.iloc[-1].isnull().sum() == 3:
        return self.history['cum_value'][-2]-sum(self.history['deposits'][:-1])-sum(self.history['fees'][:-1])
    
    return self.history['cum_value'][-1]-sum(self.history['deposits'])-sum(self.history['fees'])

# %% ../nbs/00_portfolio.ipynb 60
create_monthly_rebalance_dates =  lambda start, end: pd.bdate_range(start=to_datetime(start),end=to_datetime(end),freq='BM')
