# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_portfolio.ipynb.

# %% auto 0
__all__ = ['to_datetime', 'create_monthly_rebalance_dates', 'create_monthly_deposits', 'Holding', 'FixedAllocationPortfolio',
           'Returns']

# %% ../nbs/00_portfolio.ipynb 3
from fastcore.utils import *

# %% ../nbs/00_portfolio.ipynb 6
import yfinance as yf

# %% ../nbs/00_portfolio.ipynb 14
import pandas as pd
from datetime import datetime

# %% ../nbs/00_portfolio.ipynb 15
to_datetime = lambda date_string: datetime.strptime(date_string,"%d/%m/%Y")
def create_monthly_deposits(start:str,        # Date of the first montly deposit.
                            end:str,          # Date of the last monthly deposit
                            deposit:float):    # Value of monthly deposit
    dti = pd.bdate_range(start=to_datetime(start),end=to_datetime(end),freq='BM')
    deposits = [deposit]*len(dti)
    return pd.Series([deposit]*len(dti), index=dti, name='deposits')

# %% ../nbs/00_portfolio.ipynb 28
import warnings

# %% ../nbs/00_portfolio.ipynb 29
class Holding:
    "A holding for fund with data available on yfinance"
    def __init__(self,
                 fund:str,                      # Name of the fund
                 ticker:str,                    # Ticker symbol for the stock
                 product_cost:float,            # Sum of all fees expressed as a percentage
                 deposits):                     # Timeseries dataframe of deposits
                 
        
        self.fund = fund
        self.product_cost = product_cost
        
        # Where we've specified a timeseries where values predate the oldest time in our ticker,
        # we give a warning and then fill the deposits columns with nans and back-fill all other columns
        
        price_history = yf.Ticker(ticker).history(period='max', # valid periods: 1d,5d,1mo,3mo,6mo,1y,2y,5y,10y,ytd,max
                                                  interval='1d', # valid intervals: 1m,2m,5m,15m,30m,60m,90m,1h,1d,5d,1wk,1mo,3mo
                                                  actions=False)
        if price_history.shape[0] == 0:
            raise Exception(f"No fund data available for {ticker}") 
        
        #TODO: Or if there is no overlap before i.e. code assumes deposits can predate fund only.        
        if deposits.index[0] < price_history.index[0]:
            warn_msg = f"""Deposits predate initial date of {price_history.index[0]} where prices are available for {fund}. First pricing data is back-filled.""" 
            warnings.warn(warn_msg)
        elif deposits.index[0] > price_history.index[-1]:
            warn_msg = f"""{fund} closed on {price_history.index[-1]} before the first deposit on {deposits.index[0]}.""" 
            warnings.warn(warn_msg)
        
        # Trim any fund data that predates deposits
        price_history = price_history.iloc[price_history.index >= deposits.index[0]]
        
        # Join and clean
        self.history = pd.merge(deposits.to_frame(),price_history,left_index=True,right_index=True,how='outer')
        dti = pd.date_range(start=self.history.index[0],end=datetime.now())
        self.history = self.history.reindex(dti)
        self.history['deposits'] = self.history['deposits'].fillna(0)
        self.history = self.history.fillna(method='bfill')
        self.history = self.history.fillna(method='ffill')
        
        self = self.compute_value()
        
    def compute_value(self):
        
        self.history['units']        = self.history['deposits']/self.history['Close']
        self.history['cum_units']    = self.history['units'].cumsum()
        self.history['cum_value']    = self.history['cum_units']*self.history['Close']
        self.history['fees'] = ((1+self.product_cost/100)**(1/365)-1)*self.history['cum_value']
        
        return self

# %% ../nbs/00_portfolio.ipynb 56
class FixedAllocationPortfolio:
    "A collection of holdings of funds with data available on yfinance with a fixed allocation of each deposit made."
    def __init__(self,
                 fund:list,          # List of fund names
                 ticker:list,        # List of fund tickers
                 product_cost:list,  # List of fees for each fund expressed as a percentage and comprising all fees for a given fund
                 allocation:list,    # Allocation of each deposit as a fraction. Must sum to one.
                 deposits):          # Timeseries dataframe of deposits
        
        # Check fund, ticker, product_cost and allocation are all lists of equal length
        assert(all([len(input)==len(fund) for input in [ticker, product_cost, allocation]]))
        
        # Check that allocation sums to 1
        assert(sum(allocation)==1)
        
        # Record the inputs
        self.deposits = deposits
        self.allocation = allocation
        self.fund = fund
        
        # Create a holding for each fund
        self.holdings = [Holding(fund[i],ticker[i],product_cost[i],deposits*allocation[i]) for i in range(len(fund))]
               
    def rebalance(self,rebalance_dates):
        
        # We rebalance on the dates specified. If a rebalancing date is prior a funds 
        # inception date then the fund's deposit is used in the rebalancing.
        
        # It is assumed that fees are paid for with an external account and that the fees
        # are accrued daily.
        
        holdings = self.holdings
        
        # The holdings are identical so we can use any one
        matching_rows = holdings[0].history.index.get_indexer(rebalance_dates,method='nearest')
        
        # Get column references
        cum_value_idx = holdings[0].history.columns.get_loc("cum_value")
        deposit_idx = holdings[0].history.columns.get_loc("deposits")
        
        for row in matching_rows:
            
            # Compute the current allocation
            current_allocation = [holdings[i].history.iloc[row].loc['cum_value']
                                 for i in range(len(holdings))]
            
            # Compute target allocations based on asset weightings
            total_value = sum(current_allocation)
            target_allocation = [fraction*total_value for fraction in self.allocation]
            
            for i in range(len(holdings)):
                holdings[i].history.iloc[row,deposit_idx] = holdings[i].history.iloc[row,deposit_idx] \
                                                                   + (target_allocation[i] - holdings[i].history.iloc[row,cum_value_idx])
                holdings[i].compute_value()
            
        self.holdings = holdings
        return self

# %% ../nbs/00_portfolio.ipynb 61
class Returns:
    def __init__(self,
                 name:    str ,   # Description of the returns - typically used as title
                 holdings: list):  # List of holdings
    
            self.name = name
            self.history = holdings[0].history[["deposits","cum_value","fees"]]
            for i in range(1,len(holdings)):
                self.history += holdings[i].history[["deposits","cum_value","fees"]]

# %% ../nbs/00_portfolio.ipynb 63
@patch
def to_returns(self:Holding):
    return Returns(self.fund,[self])

# %% ../nbs/00_portfolio.ipynb 68
@patch
def to_returns(self:FixedAllocationPortfolio):
    
    name = f"{100*self.allocation[0]}% {self.fund[0]}"
    for i in range(1,len(self.holdings)):
        name += f", {100*self.allocation[i]}% {self.fund[i]}"

    return Returns(name,self.holdings)

# %% ../nbs/00_portfolio.ipynb 73
@patch
def profit(self:Returns):
    
    if self.history.iloc[-1].isnull().sum() == 3:
        return self.history['cum_value'][-2]-sum(self.history['deposits'][:-1])-sum(self.history['fees'][:-1])
    
    return self.history['cum_value'][-1]-sum(self.history['deposits'])-sum(self.history['fees'])

# %% ../nbs/00_portfolio.ipynb 79
create_monthly_rebalance_dates =  lambda start, end: pd.bdate_range(start=to_datetime(start),end=to_datetime(end),freq='BM')
